Beneath here is two original files, utils.js and api.js, and after them I will add snippets of new code from the documentation of ScryDex to properly fetch sets, card images, names, prices etcetera.
this is utils.js:
/**
 * utils.js
 * Contains helper and utility functions for data transformation and formatting.
 */

/**
 * Creates a debounced function that delays invoking `func` until after `wait` milliseconds have elapsed
 * since the last time the debounced function was invoked.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function} Returns the new debounced function.
 */
export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Transforms a Scryfall card object into the app's standard format.
 * @param {object} scryfallCard - The raw card object from the Scryfall API.
 * @returns {object} A standardized card object.
 */
export function transformScryfallCard(scryfallCard) {
    return {
        api_id: scryfallCard.id,
        name: scryfallCard.name,
        set: scryfallCard.set,
        set_name: scryfallCard.set_name,
        rarity: scryfallCard.rarity,
        image_uris: scryfallCard.image_uris,
        prices: {
            usd: scryfallCard.prices?.usd || null,
            usd_foil: scryfallCard.prices?.usd_foil || null,
        },
        purchasePrice: 0,
        collector_number: scryfallCard.collector_number,
        color_identity: scryfallCard.color_identity,
        type_line: scryfallCard.type_line,
        game: 'mtg',
    };
}


/**
 * Transforms a Pokémon TCG API card object into the app's standard format.
 * This function is now robust and safely handles missing data.
 * @param {object} pokemonCard - The raw card object from the Pokémon TCG API.
 * @returns {object} A standardized card object.
 */
export function transformPokemonCard(pokemonCard) {
    const prices = pokemonCard.tcgplayer?.prices || {};
    const normalPrice = prices?.normal?.market
        || prices?.unlimited?.market
        || prices?.holofoil?.market
        || null;
    const foilPrice = prices?.holofoil?.market
        || prices?.reverseHolofoil?.market
        || prices?.["1stEditionHolofoil"]?.market
        || null;

    const image_uris = {
        small: pokemonCard.images?.small || '',
        normal: pokemonCard.images?.large || '',
        large: pokemonCard.images?.large || '',
        art_crop: pokemonCard.images?.large || '',
    };

    return {
        api_id: pokemonCard.id,
        name: pokemonCard.name,
        set: pokemonCard.set.id,
        set_name: pokemonCard.set.name,
        rarity: pokemonCard.rarity || 'Common',
        image_uris: image_uris,
        // Keep the original images object for backward compatibility with saved cards
        images: pokemonCard.images,
        prices: {
            usd: normalPrice,
            usd_foil: foilPrice,
        },
        purchasePrice: 0,
        collector_number: pokemonCard.number,
        type_line: pokemonCard.supertype + (pokemonCard.subtypes ? ` - ${pokemonCard.subtypes.join(' ')}` : ''),
        game: 'pokemon',
    };
}

// --- START: CORRECTED IMAGE URL LOGIC ---
/**
 * Gets a reliable image URL from a card object, supporting both old and new data structures.
 * @param {object} card - The card object.
 * @returns {string} The URL for the card image.
 */
export function getCardImageUrl(card) {
    if (card.customImageUrl) {
        return card.customImageUrl;
    }
    // Handles both Scryfall (direct properties) and ScryDex (nested) image objects
    if (card.image_uris && card.image_uris.normal) {
        return card.image_uris.normal;
    }
    // Fallback for older data structures or direct image links
    if (card.image_uris) {
        return card.image_uris;
    }
    return 'images/placeholder.png'; // Default placeholder
}
// --- END: CORRECTED IMAGE URL LOGIC ---


/**
 * Formats a price string.
 * @param {number|string|null} price - The price to format.
 * @param {string} currency - The currency code (e.g., 'USD').
 * @returns {string} The formatted price string (e.g., '$1.23').
 */
export function formatPrice(price, currency = 'USD') {
    const numericPrice = parseFloat(price);
    if (isNaN(numericPrice)) {
        return 'N/A';
    }
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency,
    }).format(numericPrice);
}
this is api.js:
// public/js/modules/api.js

/**
 * api.js
 * Final, stable version with corrected ScryDex integration and error handling.
 * Handles all external API calls (Scryfall, ScryDex via Firebase) and Firestore interactions.
 * Supports multiple TCGs and user-selectable price regions.
 */

import { debounce } from './utils.js';

const db = firebase.firestore();
const storage = firebase.storage();
const functions = firebase.functions();

// ScryDex cloud function
const searchScryDexFunction = functions.httpsCallable('searchScryDex');

// --- CARD SEARCH APIS ---

/**
 * Main search router with improved error handling.
 * For MTG, it checks the user's preference for EU (Scryfall) or US (ScryDex) prices.
 * For all other games, it defaults to ScryDex.
 */
export async function searchCards(cardName, game) {
    console.log(`[API] Searching for "${cardName}" in game: ${game}`);

    if (!cardName || cardName.trim().length < 3) {
        throw new Error('Card name must be at least 3 characters long.');
    }

    const priceProvider = localStorage.getItem('priceProvider') || 'scryfall';

    try {
        if (game === 'mtg' && priceProvider === 'scryfall') {
            console.log('[API] Using Scryfall for MTG with EU prices');
            return await searchScryfall(cardName);
        }

        console.log(`[API] Using ScryDex for ${game}`);
        return await searchScryDex(cardName, game);
    } catch (error) {
        console.error(`[API] Search failed for "${cardName}" in ${game}:`, error);
        throw new Error(`Failed to search for cards: ${error.message}`);
    }
}

/**
 * Fetches card data directly from Scryfall for EU pricing with improved error handling.
 */
async function searchScryfall(cardName) {
    const encodedUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(cardName)}&unique=prints`;

    try {
        console.log('[API] Making Scryfall request:', encodedUrl);
        await new Promise(resolve => setTimeout(resolve, 100)); // Respect rate limits
        const response = await fetch(encodedUrl);

        if (!response.ok) {
            if (response.status === 404) return []; // A 404 from Scryfall means no cards were found
            const errorData = await response.json().catch(() => ({ details: 'Unknown error' }));
            throw new Error(errorData.details || `HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        if (!data.data || !Array.isArray(data.data)) {
            return [];
        }

        console.log(`[API] Scryfall returned ${data.data.length} results`);
        return data.data.map(card => cleanScryfallData(card));
    } catch (error) {
        console.error('[API] Scryfall API error:', error);
        throw error;
    }
}

/**
 * FIX: Fetches card data using the cloud function and correctly parses the nested response.
 */
async function searchScryDex(cardName, game) {
    try {
        console.log(`[API] Calling ScryDex function for ${game} with query: "${cardName}"`);
        const result = await searchScryDexFunction({ cardName, game });
        console.log('[API] ScryDex function raw result:', result);

        // **CRITICAL FIX IS HERE:** Restore the original robust response handling.
        // The result from a callable function has the data nested. The cloud function itself
        // also returns an object with a 'data' key, leading to result.data.data.
        let cardData;
        if (result && result.data && Array.isArray(result.data.data)) {
            cardData = result.data.data;
        } else if (result && Array.isArray(result.data)) {
            cardData = result.data;
        } else {
             console.warn('[API] Unexpected ScryDex response format:', result);
            cardData = [];
        }

        if (cardData.length === 0) {
            console.log('[API] ScryDex returned 0 results.');
            return [];
        }

        console.log(`[API] ScryDex returned ${cardData.length} results`);
        return cardData.map(card => cleanScryDexData(card, game));

    } catch (error) {
        console.error(`[API] ScryDex search function error for ${game}:`, error);
        if (error.code === 'functions/not-found') {
            throw new Error('ScryDex search service is currently unavailable.');
        } else if (error.code === 'functions/permission-denied' || error.code === 'functions/unauthenticated') {
            throw new Error('Authentication required. Please log in again.');
        }
        throw new Error(error.message || `Could not fetch ${game} cards from ScryDex.`);
    }
}

/**
 * A debounced version of the searchCards function to limit API calls while typing.
 */
export const debouncedSearchCards = debounce(searchCards, 300);


// --- DATA CLEANING ---

/**
 * Cleans data from a Scryfall API response.
 */
function cleanScryfallData(card) {
    const prices = card.prices ? {
        usd: card.prices.usd ? parseFloat(card.prices.usd) : null,
        usd_foil: card.prices.usd_foil ? parseFloat(card.prices.usd_foil) : null,
        eur: card.prices.eur ? parseFloat(card.prices.eur) : null,
        eur_foil: card.prices.eur_foil ? parseFloat(card.prices.eur_foil) : null,
    } : { usd: null, usd_foil: null, eur: null, eur_foil: null };

    const image_uris = card.image_uris || (card.card_faces && card.card_faces[0].image_uris) || null;
    const mana_cost = card.mana_cost || (card.card_faces && card.card_faces[0].mana_cost) || null;

    return {
        api_id: card.id,
        name: card.name,
        set: card.set,
        set_name: card.set_name,
        rarity: card.rarity,
        image_uris: image_uris,
        card_faces: card.card_faces || null,
        prices: prices,
        mana_cost: mana_cost,
        cmc: card.cmc,
        type_line: card.type_line,
        color_identity: card.color_identity,
        collector_number: card.collector_number,
        game: 'mtg'
    };
}

/**
 * Cleans data from a ScryDex API response based on official documentation.
 */
function cleanScryDexData(card, game) {
    try {
        const prices = {
            usd: parseFloat(card.prices?.usd?.market) || null,
            usd_foil: parseFloat(card.prices?.usd_foil?.market) || null,
        };

        const image_uris = {
            small: card.images?.small || null,
            normal: card.images?.normal || null,
            large: card.images?.large || null,
        };

        const cleaned = {
            api_id: card.id,
            name: card.name || 'Unknown Card',
            set: card.set?.id || 'unknown',
            set_name: card.set?.name || 'Unknown Set',
            rarity: card.rarity || 'Common',
            image_uris: image_uris,
            prices: prices,
            collector_number: card.collector_number || '',
            game: game
        };

        switch (game) {
            case 'mtg':
                cleaned.mana_cost = card.mana_cost || '';
                cleaned.cmc = card.cmc || 0;
                cleaned.type_line = card.type_line || '';
                cleaned.oracle_text = card.oracle_text || '';
                cleaned.color_identity = card.color_identity || [];
                break;
            case 'pokemon':
                cleaned.types = card.types || [];
                cleaned.hp = card.hp || null;
                cleaned.supertype = card.supertype || '';
                cleaned.subtypes = card.subtypes || [];
                cleaned.abilities = card.abilities || [];
                cleaned.attacks = card.attacks || [];
                cleaned.weaknesses = card.weaknesses || [];
                cleaned.resistances = card.resistances || [];
                cleaned.retreat_cost = card.retreat_cost || [];
                cleaned.artist = card.artist || '';
                cleaned.flavor_text = card.flavor_text || '';
                break;
            case 'lorcana':
                cleaned.name = card.Name || 'Unknown Card';
                cleaned.cost = card.Cost || 0;
                cleaned.type = card.Type || '';
                cleaned.color = card.Color || '';
                cleaned.inkable = card.Inkable || false;
                cleaned.body_text = card.Body_Text || '';
                cleaned.flavor_text = card.Flavor_Text || '';
                cleaned.artist = card.Artist || '';
                cleaned.strength = card.Strength || null;
                cleaned.willpower = card.Willpower || null;
                cleaned.lore = card.Lore || null;
                break;
            case 'gundam':
                cleaned.code = card.code || '';
                cleaned.level = card.level || 0;
                cleaned.cost = card.cost || 0;
                cleaned.color = card.color || '';
                cleaned.card_type = card.card_type || '';
                cleaned.effect = card.effect || '';
                cleaned.zone = card.zone || '';
                cleaned.trait = card.trait || '';
                cleaned.link = card.link || '';
                cleaned.ap = card.ap || null;
                cleaned.hp = card.hp || null;
                cleaned.source_title = card.source_title || '';
                break;
        }
        return cleaned;
    } catch (error) {
        console.error(`[API] Error cleaning ScryDex data for ${game}:`, error, card);
        return {
            api_id: `${game}_error_${Date.now()}`,
            name: card.name || 'Error Loading Card',
            set_name: 'Unknown Set',
            rarity: 'Common',
            image_uris: null,
            prices: { usd: null, usd_foil: null },
            game: game
        };
    }
}


// --- FIRESTORE DATABASE OPERATIONS ---
const getCollectionRef = (userId) => db.collection('users').doc(userId).collection('collection');
const getWishlistRef = (userId) => db.collection('users').doc(userId).collection('wishlist');

export async function getCollection(userId) {
    const snapshot = await getCollectionRef(userId).orderBy('addedAt', 'desc').get();
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}
export async function getWishlist(userId) {
    const snapshot = await getWishlistRef(userId).orderBy('addedAt', 'desc').get();
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}
export async function addCardToCollection(userId, cardData) {
    const docRef = await getCollectionRef(userId).add(cardData);
    return docRef.id;
}
export async function updateCardInCollection(userId, cardId, updates) {
    await getCollectionRef(userId).doc(cardId).update(updates);
}
export async function deleteCardFromCollection(userId, cardId) {
    await getCollectionRef(userId).doc(cardId).delete();
}
export async function batchDeleteCards(userId, cardIds) {
    const batch = db.batch();
    const collectionRef = getCollectionRef(userId);
    cardIds.forEach(id => {
        batch.delete(collectionRef.doc(id));
    });
    await batch.commit();
}
export async function batchUpdateCards(userId, updates) {
    const batch = db.batch();
    const collectionRef = getCollectionRef(userId);
    updates.forEach(update => {
        batch.update(collectionRef.doc(update.id), update.data);
    });
    await batch.commit();
}
export async function uploadCustomImage(userId, cardId, file) {
    const filePath = `users/${userId}/collection_images/${cardId}/${file.name}`;
    const fileRef = storage.ref(filePath);
    const snapshot = await fileRef.put(file);
    return snapshot.ref.getDownloadURL();
}